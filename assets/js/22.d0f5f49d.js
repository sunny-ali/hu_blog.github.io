(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{501:function(t,e,s){"use strict";s.r(e);var a=s(4),n=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"在react中使用ref属性问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#在react中使用ref属性问题"}},[t._v("#")]),t._v(" 在React中使用ref属性问题：")]),t._v(" "),s("p",[t._v("在React 16.3及以上版本中使用：\nRefs是使用React.createRef()创建的，并通过ref属性附加到React元素。在构造组件时，通常将Refs分配给实例属性(LeftElectricity )，以便可以在整个组件中引用它们。")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("export default class LeftElectricity extends React.Component<{buildName:string}> {\n  constructor(props:{buildName:string}) {\n    super(props)\n    this.domWidth = React.createRef();\n  }\n  render(){\n      return(\n         <div id={'leftLine_main'}  ref={this.domWidth}>\n           <DetailArea/>\n        </div>\n   )\n  }\n}\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br")])]),s("p",[s("strong",[t._v("报错：TS2339：property 'domWidth' does not exist on type 'LeftElectricity'")]),t._v(" "),s("strong",[t._v("这是TS语法检测报的错")]),t._v("\n解决：在constructor之前插入这一行代码：")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("private domWidth: React.RefObject<HTMLDivElement>;\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[s("strong",[t._v("获取ref属性的当前DOM宽高：")]),t._v("\n在componentDidMount中可以this来获取这么写：")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("componentDidMount(): void {\n    const domWidth:any= this.domWidth.current\n this.setState({width:domWidth.clientWidth/2})\n  }\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("p",[t._v("但是在static getDerivedStateFromProps中就不能采用this.的方式来获取")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("static getDerivedStateFromProps(nextProps: any, prevState: any) {\n    const domWidth:any= this.domWidth.current//报错\n    }\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("p",[t._v("原因：getDerivedStateFromProps里面的this为undefined\nstatic静态方法只能Class(构造函数)来调用(App.staticMethod)，而实例是不能的( (new App()).staticMethod  )；\n当调用React Class组件时，该组件会实例化；\n所以，React Class组件中，静态方法getDerivedStateFromProps无权访问Class实例的this，即this为undefined。\n注意：\n默认情况下，你不能在函数组件上使用 ref 属性，因为它们没有实例：\n如果要在函数组件中使用 ref，你可以使用 forwardRef（可与 useImperativeHandle 结合使用），或者可以将该组件转化为 class 组件。\n不管怎样，你可以在函数组件内部使用 ref 属性，只要它指向一个 DOM 元素或 class 组件")]),t._v(" "),s("h2",{attrs:{id:"重点提示"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#重点提示"}},[t._v("#")]),t._v(" 重点提示：")]),t._v(" "),s("p",[t._v("一定要看清当前项目中react的版本，因为在16.3之前的版本是通过字符串或回调函数方式来使用ref属性的\n1.字符串\n通过 this.refs.test 来引用真实dom的节点\ndom 节点上使用")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('<input type ="text" ref="test"/> \n')])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("2.回调函数\n回调函数就是在dom节点或组件上挂载函数，函数的入参是dom节点或组件实例，达到的效果与字符串形式是一样的，\n都是获取其引用。")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('<input type="text" ref={(input)=>{this.textInput=input}} \n')])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("最后要弄清楚到底是TS语法报错还是React语法报错！")])])}),[],!1,null,null,null);e.default=n.exports}}]);